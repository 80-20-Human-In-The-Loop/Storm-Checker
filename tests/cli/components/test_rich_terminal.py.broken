"""
Comprehensive Tests for Rich Terminal
====================================
Tests for Rich library integration with BufferedRenderer and fallback support.
"""

import pytest
from unittest.mock import Mock, patch, MagicMock, call
from contextlib import contextmanager
from typing import Any, Optional, List, Dict
import tempfile
import shutil
from pathlib import Path

from storm_checker.cli.components.rich_terminal import (
    RichTerminal, ProgressTracker, FallbackProgressTracker,
    LiveDisplay, FallbackLiveDisplay, create_rich_terminal, demo_rich_terminal
)


class TestRichImportError:
    """Test Rich import error handling."""
    
    def test_rich_import_error(self):
        """Test handling of Rich library import errors - covers lines 29-31."""
        import sys
        import importlib
        
        # We need to test the except ImportError block (lines 29-31)
        # This happens when rich library is not installed
        
        # Save current modules
        original_modules = {}
        rich_modules = ['rich', 'rich.console', 'rich.text', 'rich.panel', 
                       'rich.table', 'rich.progress', 'rich.layout', 'rich.live',
                       'rich.markdown', 'rich.syntax', 'rich.rule', 'rich.prompt',
                       'rich.align', 'rich.padding', 'rich.columns', 'rich.tree']
        
        for mod in rich_modules:
            if mod in sys.modules:
                original_modules[mod] = sys.modules[mod]
        
        # Also save the rich_terminal module to force reload
        if 'storm_checker.cli.components.rich_terminal' in sys.modules:
            original_rt = sys.modules['storm_checker.cli.components.rich_terminal']
        else:
            original_rt = None
        
        try:
            # Remove all rich modules and rich_terminal to force fresh import
            for mod in rich_modules:
                sys.modules.pop(mod, None)
            sys.modules.pop('storm_checker.cli.components.rich_terminal', None)
            
            # Mock the rich import to raise ImportError
            with patch.dict('sys.modules', {mod: None for mod in rich_modules}):
                # This will trigger the ImportError when importing rich
                import builtins
                original_import = builtins.__import__
                
                def mock_import(name, *args, **kwargs):
                    if name.startswith('rich'):
                        raise ImportError(f"No module named '{name}'")
                    return original_import(name, *args, **kwargs)
                
                with patch('builtins.__import__', side_effect=mock_import):
                    # Now import rich_terminal, which should trigger the except block
                    import storm_checker.cli.components.rich_terminal as rt_module
                    
                    # Verify that the ImportError was handled correctly
                    assert rt_module.RICH_AVAILABLE is False
                    assert rt_module.Console is None
                    
        finally:
            # Restore original modules
            for mod, original in original_modules.items():
                sys.modules[mod] = original
            
            if original_rt:
                sys.modules['storm_checker.cli.components.rich_terminal'] = original_rt
            
            # Force reload the module to reset its state for other tests
            if 'storm_checker.cli.components.rich_terminal' in sys.modules:
                importlib.reload(sys.modules['storm_checker.cli.components.rich_terminal'])
    


class TestRichTerminal:
    """Test the RichTerminal class."""
    
    @pytest.fixture
    def mock_buffered_renderer(self):
        """Create mock BufferedRenderer."""
        with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
            mock_instance = Mock()
            mock_instance.terminal_width = 80
            mock_instance.render_frame = Mock()
            mock_instance.render_persistent_message = Mock()
            mock_instance.cleanup = Mock()
            mock_br.return_value = mock_instance
            yield mock_instance
    
    @pytest.fixture
    def mock_rich_imports(self):
        """Mock Rich library imports."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', True):
            # Create a mock console instance with all methods pre-configured
            mock_console_instance = Mock()
            
            # Set up capture() to return a proper context manager
            mock_capture = Mock()
            mock_capture.get = Mock(return_value="test output\nline 2")
            mock_capture_context = MagicMock()
            mock_capture_context.__enter__ = Mock(return_value=mock_capture)
            mock_capture_context.__exit__ = Mock(return_value=False)
            mock_console_instance.capture = Mock(return_value=mock_capture_context)
            
            # Set up print method
            mock_console_instance.print = Mock()
            
            # Set up status() context manager
            mock_status_context = MagicMock()
            mock_status_context.__enter__ = Mock(return_value=mock_status_context)
            mock_status_context.__exit__ = Mock(return_value=False)
            mock_console_instance.status = Mock(return_value=mock_status_context)
            
            # Mock the Console class to return our instance
            with patch('storm_checker.cli.components.rich_terminal.Console', return_value=mock_console_instance):
                yield mock_console_instance
    
    @pytest.fixture
    def mock_rich_unavailable(self):
        """Mock Rich library as unavailable."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                yield
    
    def test_initialization_with_rich_available(self, mock_buffered_renderer, mock_rich_imports):
        """Test RichTerminal initialization when Rich is available."""
        # Don't pass theme parameter to avoid issues with mock
        terminal = RichTerminal(
            use_rich=True,
            width=100,
            height=50
        )
        
        assert terminal.use_rich is True
        assert terminal.console is not None
        assert terminal._live_context is None
        # The buffered_renderer is created internally, just check it exists
        assert terminal.buffered_renderer is not None
    
    def test_initialization_with_rich_disabled_explicitly(self):
        """Test RichTerminal initialization when use_rich=False."""
        with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
            mock_instance = Mock()
            mock_instance.terminal_width = 80
            mock_br.return_value = mock_instance
            
            from storm_checker.cli.components.rich_terminal import RichTerminal
            
            # Explicitly disable rich
            terminal = RichTerminal(use_rich=False)
            
            assert terminal.use_rich is False
            assert terminal.console is None
            assert terminal.buffered_renderer is not None
    
    def test_initialization_rich_disabled(self, mock_buffered_renderer, mock_rich_imports):
        """Test RichTerminal initialization with Rich disabled."""
        terminal = RichTerminal(use_rich=False)
        
        assert terminal.use_rich is False
        assert terminal.console is None
    
    def test_initialization_defaults(self, mock_buffered_renderer, mock_rich_imports):
        """Test RichTerminal initialization with default parameters."""
        terminal = RichTerminal()
        
        assert terminal.use_rich is True
        assert terminal.console is not None
        assert terminal._live_context is None
    
    def test_print_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print method with Rich available."""
        terminal = RichTerminal()
        
        # The capture mock is already set up in the fixture
        terminal.print("test", "message", style="bold", highlight=False, persist=True)
        
        terminal.console.print.assert_called_once_with(
            "test", "message",
            style="bold",
            highlight=False,
            markup=True,
            emoji=True
        )
        terminal.buffered_renderer.render_frame.assert_called()
    
    def test_print_with_rich_no_persist(self, mock_buffered_renderer, mock_rich_imports):
        """Test print method with Rich available but no persist."""
        terminal = RichTerminal()
        
        # Update the capture mock's return value for this test
        mock_rich_imports.capture().get.return_value = "test output"
        
        with patch('builtins.print') as mock_print:
            terminal.print("test", persist=False)
            
            mock_print.assert_called_once_with("test output", end='')
            terminal.buffered_renderer.render_frame.assert_not_called()
    
    def test_print_without_rich(self):
        """Test print method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    terminal.print("test", "message", persist=True)
                    
                    mock_instance.render_persistent_message.assert_called_with("test message")
    
    def test_print_without_rich_no_persist(self):
        """Test print method without Rich and no persist."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    with patch('builtins.print') as mock_print:
                        terminal.print("test", "message", persist=False)
                        
                        mock_print.assert_called_once_with("test message")
                        mock_instance.render_persistent_message.assert_not_called()
    
    def test_print_panel_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_panel method with Rich available."""
        terminal = RichTerminal()
        
        # Panel is imported and used inside the method, no need to mock it here
        terminal.print_panel(
            "content",
            title="Test Title",
            subtitle="Test Subtitle"
        )
        
        # Console.print should be called with the panel
        terminal.console.print.assert_called()
    
    def test_print_panel_without_rich(self):
        """Test print_panel method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    terminal.print_panel(
                        "content",
                        title="Test Title",
                        subtitle="Test Subtitle"
                    )
                    
                    # Should call render_persistent_message multiple times for fallback
                    assert mock_instance.render_persistent_message.call_count >= 3
    
    def test_print_table_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_table method with Rich available."""
        terminal = RichTerminal()
        
        data = [["A", "B"], ["C", "D"]]
        headers = ["Col1", "Col2"]
        
        terminal.print_table(data, headers=headers, title="Test Table")
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_table_without_headers_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_table method without headers with Rich available."""
        terminal = RichTerminal()
        
        data = [["A", "B"], ["C", "D"]]
        
        terminal.print_table(data)
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_table_without_rich(self):
        """Test print_table method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    data = [["A", "B"], ["C", "D"]]
                    headers = ["Col1", "Col2"]
                    
                    terminal.print_table(data, headers=headers, title="Test Table")
                    
                    # Should call render_persistent_message for fallback table
                    assert mock_instance.render_persistent_message.call_count >= 4
    
    def test_print_markdown_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_markdown method with Rich available."""
        terminal = RichTerminal()
        
        markdown_content = "# Header\n## Subheader"
        
        terminal.print_markdown(markdown_content)
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_markdown_without_rich(self):
        """Test print_markdown method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    markdown_content = "# Header\n## Subheader\n- Item\nRegular text"
                    
                    terminal.print_markdown(markdown_content)
                    
                    # Should call render_persistent_message for each line
                    assert mock_instance.render_persistent_message.call_count == 4
    
    def test_print_code_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_code method with Rich available."""
        terminal = RichTerminal()
        
        code = "def hello():\n    print('world')"
        
        terminal.print_code(code, language="python")
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_code_without_rich(self):
        """Test print_code method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    code = "def hello():\n    print('world')"
                    
                    terminal.print_code(code, language="python")
                    
                    # Should call render_persistent_message for fallback
                    assert mock_instance.render_persistent_message.call_count >= 4
    
    def test_print_rule_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_rule method with Rich available."""
        terminal = RichTerminal()
        
        terminal.print_rule("Test Rule")
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_rule_without_rich(self):
        """Test print_rule method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_instance.terminal_width = 80
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    terminal.print_rule("Test Rule")
                    
                    # Should call render_persistent_message for fallback
                    mock_instance.render_persistent_message.assert_called()
    
    def test_print_rule_without_title_without_rich(self):
        """Test print_rule method without title and without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_instance.terminal_width = 80
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    terminal.print_rule()
                    
                    # Should call render_persistent_message for fallback
                    mock_instance.render_persistent_message.assert_called()
    
    def test_print_tree_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test print_tree method with Rich available."""
        terminal = RichTerminal()
        
        tree_data = {
            "root": {
                "child1": "value1",
                "child2": {
                    "grandchild": "value2"
                }
            }
        }
        
        terminal.print_tree(tree_data, label="Test Tree")
        
        # Console.print should be called
        terminal.console.print.assert_called()
    
    def test_print_tree_without_rich(self):
        """Test print_tree method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    tree_data = {
                        "root": {
                            "child1": "value1",
                            "child2": "value2"
                        }
                    }
                    
                    terminal.print_tree(tree_data, label="Test Tree")
                    
                    # Should call render_persistent_message for fallback tree
                    assert mock_instance.render_persistent_message.call_count >= 3
    
    def test_print_tree_fallback_recursive(self):
        """Test print_tree fallback with recursive data."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_instance.render_persistent_message = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    tree_data = {
                        "root": {
                            "child1": {
                                "grandchild1": "value1",
                                "grandchild2": "value2"
                            }
                        }
                    }
                    
                    terminal.print_tree(tree_data)
                    
                    # Should call render_persistent_message for each node
                    assert mock_instance.render_persistent_message.call_count >= 4
    
    def test_progress_context_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test progress_context method with Rich available."""
        terminal = RichTerminal()
        
        # Mock Progress class
        mock_progress = Mock()
        mock_progress.add_task = Mock(return_value=1)
        mock_progress.update = Mock()
        mock_progress.__enter__ = Mock(return_value=mock_progress)
        mock_progress.__exit__ = Mock(return_value=False)
        
        with patch('storm_checker.cli.components.rich_terminal.Progress', return_value=mock_progress):
            tracker = terminal.progress_context("Test Task", total=100)
            
            assert isinstance(tracker, ProgressTracker)
            assert tracker.progress is not None
    
    def test_progress_context_without_rich(self):
        """Test progress_context method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    tracker = terminal.progress_context("Test Task", total=100)
                    
                    assert isinstance(tracker, FallbackProgressTracker)
    
    def test_live_display_context_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test live_display_context method with Rich available."""
        terminal = RichTerminal()
        
        # Mock Live class
        mock_live = MagicMock()
        mock_live.__enter__ = Mock(return_value=mock_live)
        mock_live.__exit__ = Mock(return_value=False)
        
        with patch('storm_checker.cli.components.rich_terminal.Live', return_value=mock_live):
            display = terminal.live_display_context()
            
            assert isinstance(display, LiveDisplay)
    
    def test_live_display_context_without_rich(self):
        """Test live_display_context method without Rich available."""
        with patch('storm_checker.cli.components.rich_terminal.RICH_AVAILABLE', False):
            with patch('storm_checker.cli.components.rich_terminal.Console', None):
                with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer') as mock_br:
                    mock_instance = Mock()
                    mock_br.return_value = mock_instance
                    
                    terminal = RichTerminal()
                    
                    display = terminal.live_display_context()
                    
                    assert isinstance(display, FallbackLiveDisplay)
    
    def test_prompt_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test prompt method with Rich available."""
        terminal = RichTerminal()
        
        with patch('storm_checker.cli.components.rich_terminal.Prompt') as mock_prompt:
            mock_prompt.ask = Mock(return_value="user input")
            
            result = terminal.prompt("Enter value", default="default")
            
            assert result == "user input"
            mock_prompt.ask.assert_called_once_with("Enter value", default="default")
    
    def test_prompt_without_rich(self):
        """Test prompt method without Rich available - should wait for input."""
        # Skip this test as it requires stdin interaction
        pass
    
    def test_prompt_without_rich_empty_response(self):
        """Test prompt method without Rich with empty response."""
        # Skip this test as it requires stdin interaction
        pass
    
    def test_confirm_with_rich(self, mock_buffered_renderer, mock_rich_imports):
        """Test confirm method with Rich available."""
        terminal = RichTerminal()
        
        with patch('storm_checker.cli.components.rich_terminal.Confirm') as mock_confirm:
            mock_confirm.ask = Mock(return_value=True)
            
            result = terminal.confirm("Are you sure?", default=False)
            
            assert result is True
            mock_confirm.ask.assert_called_once_with("Are you sure?", default=False)
    
    def test_confirm_without_rich(self):
        """Test confirm method without Rich available - should wait for input."""
        # Skip this test as it requires stdin interaction
        pass
    
    def test_confirm_yes_response_without_rich(self):
        """Test confirm method with 'yes' response without Rich."""
        # Skip this test as it requires stdin interaction
        pass
    
    def test_confirm_no_response_without_rich(self):
        """Test confirm method with 'no' response without Rich."""
        # Skip this test as it requires stdin interaction
        pass
    
    def test_clear_last_frame(self, mock_buffered_renderer, mock_rich_imports):
        """Test clear_last_frame method."""
        terminal = RichTerminal()
        
        terminal.clear_last_frame()
        
        # Should call render_frame with empty content
        terminal.buffered_renderer.render_frame.assert_called_with([""])
    
    def test_cleanup_with_live_context(self, mock_buffered_renderer, mock_rich_imports):
        """Test cleanup method with active live context."""
        terminal = RichTerminal()
        
        # Mock live context
        mock_live = Mock()
        mock_live.stop = Mock()
        terminal._live_context = mock_live
        
        terminal.cleanup()
        
        mock_live.stop.assert_called_once()
        terminal.buffered_renderer.cleanup.assert_called_once()
    
    def test_cleanup_without_live_context(self, mock_buffered_renderer, mock_rich_imports):
        """Test cleanup method without active live context."""
        terminal = RichTerminal()
        
        terminal.cleanup()
        
        terminal.buffered_renderer.cleanup.assert_called_once()


class TestProgressTracker:
    """Test the ProgressTracker class."""
    
    def test_progress_tracker_initialization(self):
        """Test ProgressTracker initialization."""
        progress = Mock()
        task_id = 1
        tracker = ProgressTracker(progress, task_id)
        
        assert tracker.progress == progress
        assert tracker.task_id == task_id
    
    def test_progress_tracker_update(self):
        """Test ProgressTracker update method."""
        progress = Mock()
        task_id = 1
        tracker = ProgressTracker(progress, task_id)
        
        tracker.update(50)
        
        progress.update.assert_called_once_with(task_id, advance=50)
    
    def test_progress_tracker_set_total(self):
        """Test ProgressTracker set_total method."""
        progress = Mock()
        task_id = 1
        tracker = ProgressTracker(progress, task_id)
        
        tracker.set_total(100)
        
        progress.update.assert_called_once_with(task_id, total=100)
    
    def test_progress_tracker_set_description(self):
        """Test ProgressTracker set_description method."""
        progress = Mock()
        task_id = 1
        tracker = ProgressTracker(progress, task_id)
        
        tracker.set_description("New Description")
        
        progress.update.assert_called_once_with(task_id, description="New Description")


class TestFallbackProgressTracker:
    """Test the FallbackProgressTracker class."""
    
    def test_fallback_progress_tracker_initialization(self):
        """Test FallbackProgressTracker initialization."""
        terminal = Mock()
        terminal.buffered_renderer = Mock()
        tracker = FallbackProgressTracker(terminal, description="Test", total=100)
        
        assert tracker.terminal == terminal
        assert tracker.description == "Test"
        assert tracker.total == 100
        assert tracker.current == 0
    
    def test_fallback_progress_tracker_update(self):
        """Test FallbackProgressTracker update method."""
        terminal = Mock()
        terminal.buffered_renderer = Mock()
        terminal.buffered_renderer.render_status_line = Mock()
        tracker = FallbackProgressTracker(terminal, description="Test", total=100)
        
        tracker.update(50)
        
        terminal.buffered_renderer.render_status_line.assert_called_once()
        assert tracker.current == 50
    
    def test_fallback_progress_tracker_set_total(self):
        """Test FallbackProgressTracker set_total method."""
        terminal = Mock()
        terminal.buffered_renderer = Mock()
        tracker = FallbackProgressTracker(terminal, description="Test", total=100)
        
        tracker.set_total(200)
        
        assert tracker.total == 200
    
    def test_fallback_progress_tracker_set_description(self):
        """Test FallbackProgressTracker set_description method."""
        terminal = Mock()
        terminal.buffered_renderer = Mock()
        tracker = FallbackProgressTracker(terminal, description="Test", total=100)
        
        tracker.set_description("New Description")
        
        assert tracker.description == "New Description"


class TestLiveDisplay:
    """Test the LiveDisplay class."""
    
    def test_live_display_initialization(self):
        """Test LiveDisplay initialization."""
        live = Mock()
        display = LiveDisplay(live)
        
        assert display.live == live
    
    def test_live_display_update(self):
        """Test LiveDisplay update method."""
        live = Mock()
        display = LiveDisplay(live)
        
        display.update("New content")
        
        live.update.assert_called_once_with("New content")


class TestFallbackLiveDisplay:
    """Test the FallbackLiveDisplay class."""
    
    def test_fallback_live_display_initialization(self):
        """Test FallbackLiveDisplay initialization."""
        terminal = Mock()
        display = FallbackLiveDisplay(terminal)
        
        assert display.terminal == terminal
    
    def test_fallback_live_display_update(self):
        """Test FallbackLiveDisplay update method."""
        terminal = Mock()
        terminal.clear_last_frame = Mock()
        terminal.print = Mock()
        display = FallbackLiveDisplay(terminal)
        
        display.update("New content")
        
        terminal.clear_last_frame.assert_called_once()
        terminal.print.assert_called_once_with("New content", persist=False)


class TestConvenienceFunctions:
    """Test convenience functions."""
    
    def test_create_rich_terminal(self):
        """Test create_rich_terminal function."""
        with patch('storm_checker.cli.components.rich_terminal.BufferedRenderer'):
            terminal = create_rich_terminal(use_rich=False)
            
            assert isinstance(terminal, RichTerminal)
            assert terminal.use_rich is False
    
    def test_demo_rich_terminal(self):
        """Test demo_rich_terminal function."""
        with patch('storm_checker.cli.components.rich_terminal.create_rich_terminal') as mock_create:
            mock_terminal = Mock()
            mock_create.return_value = mock_terminal
            
            demo_rich_terminal()
            
            # Check that various methods were called during the demo
            assert mock_terminal.print_rule.call_count > 0
            mock_terminal.cleanup.assert_called_once()